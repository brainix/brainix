#summary A Brief Note of mistakes with *Nix and Plans to "Solve" them?

= Introduction =

OK, it has been [http://www.faqs.org/docs/artu/ch20s03.html noted] that there are some short comings with the Unix design. Perhaps we should try and plan how to avoid them rather than have an "Oh well, what the hell"-attitude?

= Exceptions =

OK, C does not support exceptions...naturally. Perhaps we should use [http://www.digitalmars.com/d/index.html The D Programming Language]? It is ABI compatible with (and is as capable of being as low level as) C, and it is as comfortable as Java.

Note that if we are going to use D, we either will have to use structs (note that structs can support internal functions, e.g. consider the following code segment:

{{{
struct toy {
     int a;
     void set(int b) 
     { 
          a = b; 
     }
     /* Also acceptable as:
     void set(int b) { a=b; }
      */
}
}}}

This compiles perfectly fine in D. Classes are a bit heavier in D, whereas structs are simply a POD (Plain Old Data) type; if we were to use classes, we may have to hack the GNU D compiler a bit). 

- C does have longjmp(3), which could be used in a MACRO to emulate the behavior of exceptions.  Are exceptions really that big of a deal? (james.d.taylor)

- Exceptions *won't* "make or break" the operating system, (actually *aspect* oriented programming would probably make life infinitely easier because there may be a number of exceptions that need to be caught, see the [http://en.wikipedia.org/wiki/Aspect_oriented_programming wikipedia page] on aspect oriented programming for an example of this using Java)...it would be a nice feature to have though, just something different ;) The advantages of using exceptions are covered pretty well by Raymond in the linked book I think. (pqnelson)

- Out of curiosity, what's wrong with using a minimal subset of the C++ standard? (james.d.taylor)

- Because you can't have code like this:
{{{
class Inode
{
     
     struct field;
     
     public this()
     {
          // Constructor not shown 
     }
/*
     public ~this() // The deconstructor which is not necessary as there is a garbage collector
     {
          // Deconstructor not shown 
     }
*/
     
     public char[] toString()
     {
          return "Inode.toString() @ ",&this;
     }
     
     /* Other methods not shown... */
}
}}}
Which can come in handy with, say, the virtual file system. (pqnelson)

- Sorry I'm not proficient in 'D'.  I'm pretty sure toString() on that Inode is supposed to return the name of the file, I don't see where that is defined.  I don't see how this can't be implemented in C++ just as elegantly.  Not to mention the insane (sorry) idea of using garbage collection in a kernel. (james.d.taylor)

- D is a new language, so I'd be surprised if you heard of it at all. The `toString()` method is just an example method, you could implement it to be anything you'd like really. One of the more interesting aspects of D is that garbage collection is optional (kind of like in C#)...so garbage collection wouldn't really be implemented ;) There are crazier ideas out there though. The appeal to D is that there are no prototypes or any other inane nonsense that C++ has when it comes to classes...D is a lot more like Java done right. There are pointers/references, optional memory management, etc. Unfortunately there is no good introductory tutorials to D but it's not a hard language to learn, a number of great references are on the [http://en.wikipedia.org/wiki/D_programming_language Wikipedia page] for it. In my opinion, D is a lot cleaner than C++ (making it more enjoyable to hack), allows for better in-code documentation, and is far easier to program in. Opinions may vary ;) (pqnelson)

- I've perused 'D' occasionally for a few years now.  I still think Brainix should remain either 'C' based or _minimal_ C++.  If we are going to rewrite Brainix, why not do it in 'erlang'?  Like I said.. insane.  It's already written in C, and there are a _lot_ more things to worry about than switching languages. (james.d.taylor)

- From my understanding, the structure of the kernel is going to become a modular "hybrid" kernel...so I don't see the advantage of using Erlang (admittedly I don't really like Erlang). Note that from my understanding Erlang would be incredibly useful if we were to keep programming this beast as a microkernel. I'm merely suggesting this since D *is* C with classes _done right_...and I was trained as an Object Oriented Purist which may have some small influence on my decision making ;) Bear in mind that D is ABI compatible with C, so if you don't like having a purely D (and some assembly) coded kernel, one could have alternatively D and C (and assembly) code in there. (pqnelson)

- Actually I was just discussing it with Brainix, and we kind of came across an idea: why not have modules as instantiated classes (i.e. objects)? Loading a module = instantiating a new object, unloading a module = using the object's deconstructor. It has a certain appeal to it, no? (pqnelson)

- Sounds natural, and can be done with a minimal C++.  Honestly, it should be up to the main contributers to the kernel, and I'm not one of them yet.  I need to look into both 'D' and Plan9 more seriously. (james.d.taylor)

- ooh. a D frontend to gcc. :)  Looks neat (jdt).

- I emailed the hacker in charge of the D front end for the GCC about (permanently) disabling garbage collection during compilation, and he said that I'd have to manually edit the implementation of the garbage collector in the source code to do this. Still, I think that we should use the D programming language since it would give us something different, it would be object oriented, and it's fun to program in. (pqnelson)

- Odd.. there is a 'd' USE flag for gcc in gentoo, but it doesn't do anything. (jdt)

- That's ok, even if it did work, we'll have to manually disable the garbage collector code in the GNU D front end if we decide to use D. (pqnelson)

- I have been thinking about using C++ instead of D, and I don't really mind using C++ `struct`s provided that the code style convention is that it's like a Java class _sans_ constructor, e.g.:
{{{
#include <iostream>
using namespace std;

struct test
{
	int hello;

	int toString() {
		return hello; 
	}
	void goToHell() {
		~hello;
	}
	bool someOtherFunction() {
		return ((5)==(hello));
	}
};

int main(void)
{
	test foo;
	foo.hello=5;
	cout<<foo.toString()<<endl;
	cout<<foo.someOtherFunction()<<endl;
	return 0;
}
}}}
But that's my prejudiced bigotry towards favoring object orientedness. You may disagree with me, and I shall consider you wrong :P A thought does arise about the `try { ... } catch(...) {...}` blocks, which perhaps we could possibly, conceivably, hopefully, perhaps maybe use? (pqnelson)

- Actually, I've been looking at the documentation for [http://www.on-time.com/ddj0011.htm exception handling in Embedded Systems programming] which appears to be a more luring approach for one approach. I'm still undecided, it would be nice to hack the D front end (or write our own front end -- an impossibly task :P) such that we have what we want. Of course, we only "need" assembly...everything else is just a luxury. (pqnelson)

- Just a small bibiliography for anyone reading this that wants to have a more thorough reading of exceptions in C:
[http://www.swig.org/Doc1.1/HTML/Exceptions.html Exception Handling]
[http://www.halfbakery.com/idea/C_20exception_20handling_20macros C Exception Handling Macros]
[http://ldeniau.web.cern.ch/ldeniau/html/exception/exception.html Exceptions in C]
[http://sourceforge.net/projects/cexcept/ CExcept exception handling in C]
([http://www.nicemice.net/cexcept/ More about CException])
[http://www.planatechsolutions.com/xllplus-online/start_seh2.htm C Structured Exception Handling]
[http://www.geocities.com/ravikiran_uvs/articles/exception_handling.html Exception Handling in C]
[http://www.nada.kth.se/cvap/abstracts/cvap127.html Exception Handling in ANSI C]

- Actually,the elegant version of C exception handling for C99 (it compiles with the GCC):
{{{
#ifndef EXCEPTION_H
#define EXCEPTION_H

#include <setjmp.h>

extern jmp_buf exception_buffer;
extern int exception_status;

#define try		if ((exception_status = setjmp(exception_buffer)) == 0)
#define catch(val)	else if (exception_status == val)
#define throw(val)	longjmp(exception_buffer,val)
#define finally		else

#endif /* def EXCEPTION_H */
}}}
Just thought I'd throw that out there if anyone cares :) (pqnelson)

- Not so sure about "elegant".  It reminds me of the [http://minnie.tuhs.org/UnixTree/V7/usr/src/cmd/sh/mac.h.html Bourne shell macros], which allowed for code like [http://minnie.tuhs.org/UnixTree/V7/usr/src/cmd/sh/main.c.html this]! :) (jdt)

- "Elegant" as in "I'm too lazy to try to do any better than this which works" ;P (pqnelson)

- Actually, I like it, except for the fact that it isn't thread safe, though that shouldn't matter for Brainix, right?  Oh yea, it also isn't "nested safe".. might want to replace "exception_buffer" and "exception_status" with stacks of type jmp_buf, and int.
Something like:
{{{
#ifndef EXCEPTION_H
#define EXCEPTION_H

#include <setjmp.h>

#define MAX_EXCEPTION_NEST 32

extern jmp_buf exception_buffer[MAX_EXCEPTION_NEST];
extern int exception_status[MAX_EXCEPTION_NEST];
extern int exception_stack; /* initialized to zero in implementation */

#define try if ((exception_status[exception_stack] = setjmp(exception_buffer[exception_stack++])) == 0)
#define catch(val) else if (exception_status[exception_stack] == val)
#define finalcatch(val) else if (exception_status[exception_stack--] == val)
#define throw(val) longjmp(exception_buffer[exception_stack], val)
#define finally else

#endif /* def EXCEPTION_H */
}}}
I know the "finalcatch" is fugly, but whatever.
Would also need to somehow test in "try" whether there is a stack overflow... (jdt)

- Well, I think that'll do for now JDT. That'll do...only if because I'm extraordinarily lazy :P (pqnelson)

- 32 stack frames.. the only time I can see that happening is in either extreme recursion, or the more probable infinite function dependence.  Though.. I don't see over 32 nested exceptions anytime soon..  (I'm lazy too) (jdt)

- I just realized that the code above doesn't account for at least two major features of exceptions.  First is the default catch-all "..." (I guess this is what "finally" is for), and second is the "fall through" feature, where if the exception isn't caught then it is forwarded up the stack to the next try block.  If no try block exists to catch the exception, the process terminates.  I'm not familiar with the "finally" syntax, but a quick google-search shows it exists in both java and D.  We could add a macro which would allow the programmer to forward/pass the exception in the "finally" block manually...
{{{
#define PASS() longjmp(exception_buffer[exception_stack--], val)
}}}
CAPITAL CASE to denote non-standard syntax... Then we just have to pray that longjmp(exception_buffer[-1], val) causes the process to crash. ;) (jdt)

= Device Files =

This seems to be an increasingly obvious problem with the Unix approach...e.g. the Network Device is not really supported as a block or character device file.

Perhaps a more object oriented approach would solve this problem?

- I agree about the /dev problem, but I would say it is more of a generalization of syscall problem.  As you noted, network devices almost completely rely on ioctl for their configuration.  Maybe a broader syscall array, with POSIX backwards compatibility would be a reasonable solution.  I'm not sure what you mean about an object oriented approach.  Could you be more specific? (james.d.taylor)

- Well, by an "object oriented" solution what I really meant (in a rather ambiguous way) was that it would be more of a "Plan 9"-esque solution involving the network as-a folder (or a file) and various protocols as files. Perhaps a slightly more radical approach is necessary? I have only started thinking about this as I just recently stumbled upon Raymond's book that presents a few open problems with the Unix approach. Perhaps rethinking the operating system within the context of the internet using the UNIX-philosophy should be done (though this would be a really sloppy approach to a solution). (pqnelson)

- Keeping the "everything-is-a-file" notion is something I believe in very strongly.  I've had an idea brewing for a "standard I/O namespace".  ie. Instead of just stdin/stdout/stderr, programs could export a namespace that could be accessed as files, and even mounted somewhere on the filesystem.  Imagine a user-space network daemon that could be mounted somewhere in /dev that exports whatever functionality it provides to the kernel.  Though, this could all be implemented in user-space with something like FUSE and a compliant shell, and still doesn't solve the syscall problem...  I'll have to read up on Plan9. (james.d.taylor)

- I like the idea of replacing the streams with files...something that appeals to my puritanical side ;P (I've actually wondered about this recently - streams are procedural programming abstractions, what would the corresponding object oriented abstraction be? Then it seems logical that for (Unix-like) operating systems they would be files!) I personally think that there is no system calls problem (why not add a few more specific to the network?)...but that's my lazy solution. (pqnelson)

- It's not lazy, it's elegant.  Providing an independent namespace/filesystem to replace the over-burdened syscall array is beautiful to me.  It provides for infinite kernel/user-space interaction.  The ring-0 daemons could also use this to export their services.  Move the philosophy to the user-level and you could mount e.g., apache somewhere on the filesystem and have it export its services.  Pipes are just a subset of block devices.   I have a few apps that could use this.  e.g., 'cat' could export a specific mime-type depending on the filetype.  The odd thing is that Microsoft is already doing this with their new shell! Ahh.. pipe dreams. ;) (james.d.taylor)

- woops, I misread your comment.  Less syscalls is better, IMO.  If we can define a VFS syscall infrastructure then the I/O namespace can take over. (james.d.taylor)

- Do you have any documentation for this? Because it seems like a great idea that's really following the Unix Philosophy well, but for some reason there are times that I understand it and times that I don't. I can't quite put my finger on the namespace concept, I think that also derives from Plan 9? I recollect vaguely reading something about that in the wikipedia page for Plan 9. (pqnelson)

- Documentation?  no. This is just what I want from a UNIX-like system. (james.d.taylor)

- Really there are no references on this at all? No technical papers, passages from manuals, rantings from insane professors...nihil? I feel sort of robbed :'( But I agree, that is something that ought to be demanded from a UNIX-like system. (pqnelson)

- Actually, I meant _I_ haven't written anything about it other than my notes of things TODO.  I'm sure this idea has been proposed many times before and is rather well documented.  Doesn't the hurd have this capability?  I'm going out of town today through sunday, so I won't have internet access.  (james.d.taylor)

- Just fixed a few typos and grammatical errors; I honestly do not quite understand the "translator" concept of the HURD, or anything else they're doing. Then again I'm not looking at it that much, nor am I trying that hard ;) If you could provide anything on it, I'd be ecstatic :) (pqnelson)

- Indeed, I was referring to translators in the HURD.  Honestly, it's been so long that I've forgotten the details. hehe.  From: [http://www.gnu.org/software/hurd/whatis/translator.html], I've gathered that their notion of a translator is a like a wrapper around a filesystem which can proxy the I/O through a userspace daemon.  This allows a user's specific daemon to "translate" how a file is accessed.  I'm not sure how I came up with the similarities to a "stdio namespace". (jdt)

- I just had a thought: you open and close a network connection, you receive data and "read" it, you send data ("write" it)...perhaps we could represent a network connection as a file after all? (pqnelson)

- True.. BSD sockets end up mapping to file descriptors anyway.  Each network device can have multiple addresses though, and sockets are represented by 4 unique things: local/remote IP address and local/remote port.  I'm not sure how you would abstract this to a namespace.
{{{
cat /dev/eth0/0.0.0.0/80 # would block/listen on port 80
echo "HEAD / HTTP/1.0\n\n" > /dev/eth0/127.0.0.1/80
# sends request to localhost:80

# I'd like to see something like:
$ cd /dev/net/default && web-browser
# the CWD would let the web-browser do:
  FILE *fp = fopen("google.com/http", "rw");
}}}
Clearly needs more thought.. My "ultimate" goal is to one day be able to mount my IRC client somewhere on my filesystem. :) (jdt)

- Perhaps have each device as a folder, and each address as a file therein? (pqnelson)

- Ahhh! You said "folder"! :P  Yes, but then you would need to have a way of representing ports of a socket too, because there can be multiple ports per address.  Not to mention a connected socket would have 2 addresses and 2 ports. :/ (jdt)

- Maybe the name/value pair attribute solution below could be used here to store this extra information? (jdt)

- [http://www.ibm.com/developerworks/linux/library/l-linux-networking-stack/ Here] is an interesting introduction to the Linux Network Stack internals, along with a good bibliography on the subject. (pqnelson)

- Also, [http://gicl.cs.drexel.edu/people/sevy/network/Linux_network_stack_walkthrough.html Linux Network Stack Walkthrough], and I did a similar "walk-through" a few years ago to try to figure out the stack and netfilter internals. I've uploaded it: [http://jdtaylor.org/netfilter.txt] (jdt)

- As much as I like Linux, its source organization for its networking stack is beyond ghastly.  I read W.Richard Stevens TCP/IP Illustrated Vol. 2 "The Implementation", and I highly recommend it.  Basic structures of the BSD stack, like the mbuf, should stay, but I think the "higher" portions of the network stack should have more ties to the VFS.  Also, Linux's netfilter is beautiful, IMO. (jdt)

- "As much as I like Linux, its source organization ... is beyond ghastly." Truer words have never been spoken ;) I actually agree, _a priori_, with what you say. I openly admit that networking is *not* my _forte_. That does not change the fact that it still needs to be addressed with the Unix philosophy adequately. (pqnelson)

- Do you know if anyone is working on a networking subsystem for Brainix, currently? (jdt)

- I don't think anyone is, the /brainix/doc/credits file say:

     Alex Nelson <pqnelson@ucdavis.edu>
     	     · file system hacker
     	     · debugger
	     · technical writer

     Doug Taylor <james.d.taylor@gmail.com>
	     ·

     Jagtesh <jagtesh@gmail.com>
	     · shell hacker

     Mirat Kadenov <mirat.kadenov@gmail.com>
	     · ATA hacker

     Rajiv Bakulesh Shah <brainix@gmail.com>
	     · lead (pronounced "l33t") hacker

     Rick Parrish <rfmobile@swbell.net>
	     ·

     Sam Morehouse <sam.morehouse@gmail.com>
	     · terminal hacker
It appears that no one is working, or has worked, on it. (pqnelson)

= Devices: Char vs. Block =

This is probably completely naive, but, why do we have a difference between character devices and block devices?  Couldn't a character device be a block device who's position is always at the begining of the data, and it's length be whatever the kernel happens to have buffered at the moment.  I understand certain char devices have needs like terminal devices and serial ports.  But, afaik, these are all handled the same way as special block device options... through ioctl().  I'm thinking with "stdio namespaces" we could replace pipes with subsets of two namespaces.  eg. /stdin /stdout /stderr, but if pipes aren't limited to character devices, the two piped programs could act as though they have a common namespace of files to communicate with each other. (jdt)

Perhaps we should have a different approach? There are some devices, e.g., that perfectly fit the "block" or "character" device characterizations. On the other hand, there are some which can't fit in at all. Perhaps we ought to treat all devices are an "extension" of an "abstract device"-esque class? Your approach may be better though, I should probably think about this for a while. (pqnelson)

= A Shell? =

OK, so one of the short term goals is to have a shell up and running. Perhaps we could try the Debian Almquist Shell ([http://gondor.apana.org.au/~herbert/dash/ dash])? Just a random thought that I thought might be of some relevance.

I just found [http://linuxgazette.net/111/ramankutty.html this article] in the Linux Gazette about writing a shell, it's tangentially relevant but I found it fascinating.

It appears he's just restating one of W. Richard Stevens' examples in APUE.  The problem I see is that there is a lot more to a shell than just fork/execve eg., programming constructs like 'if', 'for x in list; do', etc.  Dash would require a libc, but there is the minimal [http://en.wikipedia.org/wiki/Klibc klibc].  I downloaded the source for klibc, and to my surprise, dash is bundled with it.. (jdt)

- Isn't there some uC library that the GNU movement pieced together? Perhaps we could port it to Brainix? But a C Library would have to be written eventually... (pqnelson)

- The uC stuff is for embedded systems without a VMM.. that might be _too_ light for us.

= HAL =

Has there been discussion about a Brainix hardware abstraction layer yet?  I believe I talked, minimally, with Raj about creating a HAL and seperating x86 from a xen [http://www.cl.cam.ac.uk/research/srg/netos/xen/] wrapper. (jdt)

As far as I know, there hasn't been much discussion on the matter. Perhaps Raj has a few reservations, prejudices, or bigoted opinions on the matter, but no one has really brought up the matter. (pqnelson)

= Extended Attributes =

- The link at the top of this page repeatedly mentions MAC-like name/pair file attributes as being a good thing.  It also mentions the downsides with the 'cat' example not copying the file attributes portion.  What if we had attributes, but made them explicit members of the filesystem's namespace.  Every file would also be a directory with "sub-files" as the parent file's name-value pairs.  As the document states, this would alleviate /device configuration by avoiding ioctl() hacks.  NTFS has something like this called [http://www.securityfocus.com/infocus/1822 Alternate Data Streams], but hides it from the user and doesn't follow standard namespace conventions. (jdt)

- This is a good idea and I think it should be implementeedd; but because I'm an old fuddy duddy, when you say "namespace" I assume you mean a userspace daemon that manipulates the file system...? (pqnelson)

- I was thinking ring-0 daemons could do the same thing via the VFS.  eg. If there is a device that wants to export certain variable parameters, they could simply define these name/pair attributes of its existing filename in its mounted namespace.  The user-space could then modify the attributes via the VFS directly via /dev rather than mess with something like /proc. (jdt)

- Ah, ok, that clears up a lot, thanks :) (pqnelson)

= File System Choice =

There are a million file systems out there that are unix-like. I think that perhaps we should choose the best file system currently around.

The reason for this choice is because the virtual file system will have to be custom tailored to minimize the overhead between the kernel and the file system.

I think that perhaps we should choose, as I stated, the best file system around: the [http://www.opensolaris.org/os/community/zfs/docs/zfs_last.pdf ZFS]. 

A bibliography for the ZFS:

[http://www.opensolaris.org/os/community/zfs/ ZFS Development Community and detailed ZFS Documentation]

[http://www.opensolaris.org/os/community/zfs/source/ ZFS source code]

[http://www.asiabsdcon.org/papers/P16-slides.pdf Porting ZFS file system to FreeBSD]

[http://www.kippdata.de/pdf/Solaris_10_ZFS.pdf Solaris™ ZFS File Storage Solution]

[http://www.techworld.com/storage/features/index.cfm?featureid=2744 ZFS - the future of file systems?]

- Absolutely.. I've been looking at ZFS and its source.  Truly the best, hrm.. It kinda goes beyond a filesystem, and implements a lot of things that are available in the Linux Volume Manager + Software raid.  The Problem: Brainix is currently under the GPLv2, which is incompatible with Sun's [http://www.sun.com/cddl/ CDDL], unfortunately.  This is why Linux doesn't have native ZFS, but relies on a userspace FUSE version. Truly a shame, but I've heard rumors of Sun releasing parts into GPLv3.  ReiserFSv4, XFS, Extv3 are all good solutions with layered raid and volume management.  I'm looking for a really solid VFS that incorporates many of the things that are considered in this document.  Which filesystem to include is a sidenote. (jdt)

- I was thinking of perhaps a clone of the ZFS, perhaps we should think about it before we try anything though because they may decide to re-release the code under the GPL. Who knows. But I was (poorly attempting to begin) trying to suggest that we could clone it ;) (pqnelson)

- I don't know about cloning it.. that is a massive amount of code.  What I like about OpenSolaris is their scheduler/kernel-threads and ZFS.   I'm just waiting for the gentoo sys-kernel/open-solaris to appear.  (off-topic) their drivers suck.. especially video.  File systems are not _my_ forté. (jdt)

- File Systems _are_ my forte; but that Indiana project (or whatever the hell its called) appears to try to make Open-Solaris more Linux-like...perhaps they'll end up using Linux drivers? At any rate, I'll need to be studying the ZFS source code more since we'll be using/cloning/blah-ing it. (pqnelson)

= Documentation =

- All this talk of OpenSolaris and ZFS has reminded me of how well Sun documents their source code.  Does Brainix want such extensive comments and explanations throughout the code, or would minimal comments be more sufficient?  I happen to have a patch to Brainix which has rather heavy documentation in the parts that I've gone through already.  I did this for my own sake, because I have rather bad memory. ;) (jdt)
