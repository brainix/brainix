#summary A Brief Note of mistakes with *Nix and Plans to "Solve" them?

= Introduction =

OK, it has been [http://www.faqs.org/docs/artu/ch20s03.html noted] that there are some short comings with the Unix design. Perhaps we should try and plan how to avoid them rather than have an "Oh well, what the hell"-attitude?

= Exceptions =

OK, C does not support exceptions...naturally. Perhaps we should use [http://www.digitalmars.com/d/index.html The D Programming Language]? It is ABI compatible with (and is as capable of being as low level as) C, and it is as comfortable as Java.

Note that if we are going to use D, we either will have to use structs (note that structs can support internal functions, e.g. consider the following code segment:

{{{
struct toy {
     int a;
     void set(int b) 
     { 
          a = b; 
     }
     /* Also acceptable as:
     void set(int b) { a=b; }
      */
}
}}}

This compiles perfectly fine in D. Classes are a bit heavier in D, whereas structs are simply a POD (Plain Old Data) type; if we were to use classes, we may have to hack the GNU D compiler a bit). 

- C does have longjmp(3), which could be used in a MACRO to emulate the behavior of exceptions.  Are exceptions really that big of a deal? (james.d.taylor)

- Exceptions *won't* "make or break" the operating system, (actually *aspect* oriented programming would probably make life infinitely easier because there may be a number of exceptions that need to be caught, see the [http://en.wikipedia.org/wiki/Aspect_oriented_programming wikipedia page] on aspect oriented programming for an example of this using Java)...it would be a nice feature to have though, just something different ;) The advantages of using exceptions are covered pretty well by Raymond in the linked book I think. (pqnelson)

- Out of curiosity, what's wrong with using a minimal subset of the C++ standard? (james.d.taylor)

- Because you can't have code like this:
{{{
class Inode
{
     
     struct field;
     
     public this()
     {
          // Constructor not shown 
     }
/*
     public ~this() // The deconstructor which is not necessary as there is a garbage collector
     {
          // Deconstructor not shown 
     }
*/
     
     public char[] toString()
     {
          return "Inode.toString() @ ",&this;
     }
     
     /* Other methods not shown... */
}
}}}
Which can come in handy with, say, the virtual file system. (pqnelson)

- Sorry I'm not proficient in 'D'.  I'm pretty sure toString() on that Inode is supposed to return the name of the file, I don't see where that is defined.  I don't see how this can't be implemented in C++ just as elegantly.  Not to mention the insane (sorry) idea of using garbage collection in a kernel. (james.d.taylor)

= Device Files =

This seems to be an increasingly obvious problem with the Unix approach...e.g. the Network Device is not really supported as a block or character device file.

Perhaps a more object oriented approach would solve this problem?

- I agree about the /dev problem, but I would say it is more of a generalization of syscall problem.  As you noted, network devices almost completely rely on ioctl for their configuration.  Maybe a broader syscall array, with POSIX backwards compatibility would be a reasonable solution.  I'm not sure what you mean about an object oriented approach.  Could you be more specific? (james.d.taylor)

- Well, by an "object oriented" solution what I really meant (in a rather ambiguous way) was that it would be more of a "Plan 9"-esque solution involving the network as-a folder (or a file) and various protocols as files. Perhaps a slightly more radical approach is necessary? I have only started thinking about this as I just recently stumbled upon Raymond's book that presents a few open problems with the Unix approach. Perhaps rethinking the operating system within the context of the internet using the UNIX-philosophy should be done (though this would be a really sloppy approach to a solution). (pqnelson)

- Keeping the "everything-is-a-file" notion is something I believe in very strongly.  I've had an idea brewing for a "standard I/O namespace".  ie. Instead of just stdin/stdout/stderr, programs could export a namespace that could be accessed as files, and even mounted somewhere on the filesystem.  Imagine a user-space network daemon that could be mounted somewhere in /dev that exports whatever functionality it provides to the kernel.  Though, this could all be implemented in user-space with something like FUSE and a compliant shell, and still doesn't solve the syscall problem...  I'll have to read up on Plan9. (james.d.taylor)

- I like the idea of replacing the streams with files...something that appeals to my puritanical side ;P (I've actually wondered about this recently - streams are procedural programming abstractions, what would the corresponding object oriented abstraction be? Then it seems logical that for (Unix-like) operating systems they would be files!) I personally think that there is no system calls problem (why not add a few more specific to the network?)...but that's my lazy solution. (pqnelson)

- It's not lazy, it's elegant.  Providing an independent namespace/filesystem to replace the over-burdened syscall array is beautiful to me.  It provides for infinite kernel/user-space interaction.  The ring-0 daemons could also use this to export their services.  Move the philosophy to the user-level and you could mount e.g., apache somewhere on the filesystem and have it export its services.  Pipes are just a subset of block devices.   I have a few apps that could use this.  e.g., 'cat' could export a specific mime-type depending on the filetype.  The odd thing is that Microsoft is already doing this with their new shell! Ahh.. pipe dreams. ;) (james.d.taylor)
-- woops, I misread your comment.  Less syscalls is better, IMO.  If we can define a VFS syscall infrastructure then the I/O namespace can take over. (james.d.taylor)