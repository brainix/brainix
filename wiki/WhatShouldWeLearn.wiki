#summary A Brief Note of mistakes with *Nix and Plans to "Solve" them?

= Introduction =

OK, it has been [http://www.faqs.org/docs/artu/ch20s03.html noted] that there are some short comings with the Unix design. Perhaps we should try and plan how to avoid them rather than have an "Oh well, what the hell"-attitude?

= Exceptions =

OK, C does not support exceptions...naturally. Perhaps we should use [http://www.digitalmars.com/d/index.html The D Programming Language]? It is ABI compatible with (and is as capable of being as low level as) C, and it is as comfortable as Java.

Note that if we are going to use D, we either will have to use structs (note that structs can support internal functions, e.g. consider the following code segment:

{{{
struct toy {
     int a;
     void set(int b) 
     { 
          a = b; 
     }
     /* Also acceptable as:
     void set(int b) { a=b; }
      */
}
}}}

This compiles perfectly fine in D. Classes are a bit heavier in D, whereas structs are simply a POD (Plain Old Data) type; if we were to use classes, we may have to hack the GNU D compiler a bit). 

- C does have longjmp(3), which could be used in a MACRO to emulate the behavior of exceptions.  Are exceptions really that big of a deal? (james.d.taylor)

- Exceptions *won't* "make or break" the operating system, (actually *aspect* oriented programming would probably make life infinitely easier because there may be a number of exceptions that need to be caught, see the [http://en.wikipedia.org/wiki/Aspect_oriented_programming wikipedia page] on aspect oriented programming for an example of this using Java)...it would be a nice feature to have though, just something different ;) The advantages of using exceptions are covered pretty well by Raymond in the linked book I think. (pqnelson)

- Out of curiosity, what's wrong with using a minimal subset of the C++ standard? (james.d.taylor)

- Because you can't have code like this:
{{{
class Inode
{
     
     struct field;
     
     public this()
     {
          // Constructor not shown 
     }
/*
     public ~this() // The deconstructor which is not necessary as there is a garbage collector
     {
          // Deconstructor not shown 
     }
*/
     
     public char[] toString()
     {
          return "Inode.toString() @ ",&this;
     }
     
     /* Other methods not shown... */
}
}}}
Which can come in handy with, say, the virtual file system. (pqnelson)

- Sorry I'm not proficient in 'D'.  I'm pretty sure toString() on that Inode is supposed to return the name of the file, I don't see where that is defined.  I don't see how this can't be implemented in C++ just as elegantly.  Not to mention the insane (sorry) idea of using garbage collection in a kernel. (james.d.taylor)

- D is a new language, so I'd be surprised if you heard of it at all. The `toString()` method is just an example method, you could implement it to be anything you'd like really. One of the more interesting aspects of D is that garbage collection is optional (kind of like in C#)...so garbage collection wouldn't really be implemented ;) There are crazier ideas out there though. The appeal to D is that there are no prototypes or any other inane nonsense that C++ has when it comes to classes...D is a lot more like Java done right. There are pointers/references, optional memory management, etc. Unfortunately there is no good introductory tutorials to D but it's not a hard language to learn, a number of great references are on the [http://en.wikipedia.org/wiki/D_programming_language Wikipedia page] for it. In my opinion, D is a lot cleaner than C++ (making it more enjoyable to hack), allows for better in-code documentation, and is far easier to program in. Opinions may vary ;) (pqnelson)

- I've perused 'D' occasionally for a few years now.  I still think Brainix should remain either 'C' based or _minimal_ C++.  If we are going to rewrite Brainix, why not do it in 'erlang'?  Like I said.. insane.  It's already written in C, and there are a _lot_ more things to worry about than switching languages. (james.d.taylor)

- From my understanding, the structure of the kernel is going to become a modular "hybrid" kernel...so I don't see the advantage of using Erlang (admittedly I don't really like Erlang). Note that from my understanding Erlang would be incredibly useful if we were to keep programming this beast as a microkernel. I'm merely suggesting this since D *is* C with classes _done right_...and I was trained as an Object Oriented Purist which may have some small influence on my decision making ;) Bear in mind that D is ABI compatible with C, so if you don't like having a purely D (and some assembly) coded kernel, one could have alternatively D and C (and assembly) code in there. (pqnelson)

- Actually I was just discussing it with Brainix, and we kind of came across an idea: why not have modules as instantiated classes (i.e. objects)? Loading a module = instantiating a new object, unloading a module = using the object's deconstructor. It has a certain appeal to it, no? (pqnelson)

- Sounds natural, and can be done with a minimal C++.  Honestly, it should be up to the main contributers to the kernel, and I'm not one of them yet.  I need to look into both 'D' and Plan9 more seriously. (james.d.taylor)

- ooh. a D frontend to gcc. :)  Looks neat (jdt).

- I emailed the hacker in charge of the D front end for the GCC about (permanently) disabling garbage collection during compilation, and he said that I'd have to manually edit the implementation of the garbage collector in the source code to do this. Still, I think that we should use the D programming language since it would give us something different, it would be object oriented, and it's fun to program in. (pqnelson)

- Just upgraded to GCC-4.2.0, and the D frontend is gone... so, back to 4.1.2 I go.

= Device Files =

This seems to be an increasingly obvious problem with the Unix approach...e.g. the Network Device is not really supported as a block or character device file.

Perhaps a more object oriented approach would solve this problem?

- I agree about the /dev problem, but I would say it is more of a generalization of syscall problem.  As you noted, network devices almost completely rely on ioctl for their configuration.  Maybe a broader syscall array, with POSIX backwards compatibility would be a reasonable solution.  I'm not sure what you mean about an object oriented approach.  Could you be more specific? (james.d.taylor)

- Well, by an "object oriented" solution what I really meant (in a rather ambiguous way) was that it would be more of a "Plan 9"-esque solution involving the network as-a folder (or a file) and various protocols as files. Perhaps a slightly more radical approach is necessary? I have only started thinking about this as I just recently stumbled upon Raymond's book that presents a few open problems with the Unix approach. Perhaps rethinking the operating system within the context of the internet using the UNIX-philosophy should be done (though this would be a really sloppy approach to a solution). (pqnelson)

- Keeping the "everything-is-a-file" notion is something I believe in very strongly.  I've had an idea brewing for a "standard I/O namespace".  ie. Instead of just stdin/stdout/stderr, programs could export a namespace that could be accessed as files, and even mounted somewhere on the filesystem.  Imagine a user-space network daemon that could be mounted somewhere in /dev that exports whatever functionality it provides to the kernel.  Though, this could all be implemented in user-space with something like FUSE and a compliant shell, and still doesn't solve the syscall problem...  I'll have to read up on Plan9. (james.d.taylor)

- I like the idea of replacing the streams with files...something that appeals to my puritanical side ;P (I've actually wondered about this recently - streams are procedural programming abstractions, what would the corresponding object oriented abstraction be? Then it seems logical that for (Unix-like) operating systems they would be files!) I personally think that there is no system calls problem (why not add a few more specific to the network?)...but that's my lazy solution. (pqnelson)

- It's not lazy, it's elegant.  Providing an independent namespace/filesystem to replace the over-burdened syscall array is beautiful to me.  It provides for infinite kernel/user-space interaction.  The ring-0 daemons could also use this to export their services.  Move the philosophy to the user-level and you could mount e.g., apache somewhere on the filesystem and have it export its services.  Pipes are just a subset of block devices.   I have a few apps that could use this.  e.g., 'cat' could export a specific mime-type depending on the filetype.  The odd thing is that Microsoft is already doing this with their new shell! Ahh.. pipe dreams. ;) (james.d.taylor)

- woops, I misread your comment.  Less syscalls is better, IMO.  If we can define a VFS syscall infrastructure then the I/O namespace can take over. (james.d.taylor)

- Do you have any documentation for this? Because it seems like a great idea that's really following the Unix Philosophy well, but for some reason there are times that I understand it and times that I don't. I can't quite put my finger on the namespace concept, I think that also derives from Plan 9? I recollect vaguely reading something about that in the wikipedia page for Plan 9. (pqnelson)

- Documentation?  no. This is just what I want from a UNIX-like system. (james.d.taylor)

- Really there are no references on this at all? No technical papers, passages from manuals, rantings from insane professors...nihil? I feel sort of robbed :'( But I agree, that is something that ought to be demanded from a UNIX-like system. (pqnelson)

- Actually, I meant _I_ haven't written anything about it other than my notes of things TODO.  I'm sure this idea has been proposed many times before and is rather well documented.  Doesn't the hurd have this capability?  I'm going out of town today through sunday, so I won't have internet access.  (james.d.taylor)

- Just fixed a few typos and grammatical errors; I honestly do not quite understand the "translator" concept of the HURD, or anything else they're doing. Then again I'm not looking at it that much, nor am I trying that hard ;) If you could provide anything on it, I'd be ecstatic :) (pqnelson)

- Indeed, I was referring to translators in the HURD.  Honestly, it's been so long that I've forgotten the details. hehe.  From: [http://www.gnu.org/software/hurd/whatis/translator.html], I've gathered that their notion of a translator is a like a wrapper around a filesystem which can proxy the I/O through a userspace daemon.  This allows a user's specific daemon to "translate" how a file is accessed.  I'm not sure how I came up with the similarities to a "stdio namespace".

= Devices: Char vs. Block =

This is probably completely naive, but, why do we have a difference between character devices and block devices?  Couldn't a character device be a block device who's position is always at the begining of the data, and it's length be whatever the kernel happens to have buffered at the moment.  I understand certain char devices have needs like terminal devices and serial ports.  But, afaik, these are all handled the same way as special block device options... through ioctl().  I'm thinking with "stdio namespaces" we could replace pipes with subsets of two namespaces.  eg. /stdin /stdout /stderr, but if pipes aren't limited to character devices, the two piped programs could act as though they have a common namespace of files to communicate with each other. (jdt)

Perhaps we should have a different approach? There are some devices, e.g., that perfectly fit the "block" or "character" device characterizations. On the other hand, there are some which can't fit in at all. Perhaps we ought to treat all devices are an "extension" of an "abstract device"-esque class? Your approach may be better though, I should probably think about this for a while. (pqnelson)

= A Shell? =

OK, so one of the short term goals is to have a shell up and running. Perhaps we could try the Debian Almquist Shell ([http://gondor.apana.org.au/~herbert/dash/ dash])? Just a random thought that I thought might be of some relevance.

I just found [http://linuxgazette.net/111/ramankutty.html this article] in the Linux Gazette about writing a shell, it's tangentially relevant but I found it fascinating.

It appears he's just restating one of W. Richard Stevens' examples in APUE.  The problem I see is that there is a lot more to a shell than just fork/execve eg., programming constructs like 'if', 'for x in list; do', etc.  Dash would require a libc, but there is the minimal [http://en.wikipedia.org/wiki/Klibc klibc].  I downloaded the source for klibc, and to my surprise, dash is bundled with it.. (jdt)

- Isn't there some uC library that the GNU movement pieced together? Perhaps we could port it to Brainix? But a C Library would have to be written eventually... (pqnelson)

- The uC stuff is for embedded systems without a VMM.. that might be _too_ light for us.

= HAL =

Has there been discussion about a Brainix hardware abstraction layer yet?  I believe I talked, minimally, with Raj about creating a HAL and seperating x86 from a xen [http://www.cl.cam.ac.uk/research/srg/netos/xen/] wrapper. (jdt)

As far as I know, there hasn't been much discussion on the matter. Perhaps Raj has a few reservations, prejudices, or bigoted opinions on the matter, but no one has really brought up the matter. (pqnelson)