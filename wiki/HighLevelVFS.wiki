#summary Proposal for a High-Level Virtual File System

= Introduction =

I'm putting this here because I don't want to taint [http://code.google.com/p/brainix/wiki/virtualFileSystem Alex's fine research] on different VFS implentations with my naive opinions.

It appears to me that there should be two levels of VFS.  A high-level VFS which abstracts a virtual namespace which is presented to the user, and a low-level VFS which abstracts the physical file-systems that the OS supports.

This would be a bit similar to something like gnome-vfs or [http://mail.gnome.org/archives/gtk-devel-list/2007-February/msg00062.html gvfs], though a micro-kernel has certain aspects that can provide for a more elegant solution instead of add-on "hacks" like gnome-vfs and [http://en.wikipedia.org/wiki/Filesystem_in_Userspace FUSE].

= Details =

Since Alex has already touched on several different low-level implementations of virtual file systems, I'd like to propose a higher-level implementation which would co-exist with a lower-level implementation.

Brainix processes would register themselves as being capable of exporting a namespace to the VFS along with a preferred mount point in the global namespace.  The VFS would then store in memory every registered mountpoint/process pair in some efficient hash of the mountpoint name.  When an open() is handled, it would search this hash for the longest matching mountpoint and forward the request to the matching process.  Most normal requests for actual file access would end up mapping to whichever process is mounted to root '/' and, in this case, passed on to the ext2 process (which would have registered itself with the higher-level VFS as '/' during the bootstrap process).
If implemented, any Brainix process/module/driver could then mount its capabilities/settings somewhere on the global namespace.  Namely, the network subsystem could register itself during its initialization to eg. '/sys/net'.  Device drivers could also do the same thing for the '/dev/' namespace.

The VFS would also have to forward any opened file requests via their integer file descriptor to the process determined during the call to open().  This mapping would also have to be stored in memory.

Obviously this is not new.  Linux has gone through /proc, devfs, udev, sysfs, and FUSE which accomplish the same goals.

= VFS Ops =

It is my opinion that only a small subset of traditional syscall/vfs routines are necessary for such a system:
{{{
typedef struct
{
    long (*open)(const char* filename, int flags, int mode);
    long (*close)(unsigned int fd, int flags);
    size_t (*read)(unsigned int fd, char *buf, size_t count);
    size_t (*write)(unsigned int fd, const char *buf, size_t count);
    int (*execve)(const char *filename, char *const argv[], char *const envp[]);
} vfs_ops_t;
}}}

Regarding the many missing routines, see my [http://code.google.com/p/brainix/wiki/RejuvenateUNIX writing] on using the namespace to replace syscall/VFS functionality.  Essentially, we can use standard and unique filenames as replacements for the missing routines.  We could either use the "^." hidden file nomenclature, or I would prefer a prefix that wouldn't collide with existing tradition eg., a comma instead of a dot.

- Actually, the [http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf Original Sun Implementation] Of the virtual file system (see page 3) has the operations on the file system that are sort of "miscellaneous". The virtual file system, usually, also includes the system calls like `read()`, `write()`, `open()`, and `close()` outside of the `vfsops`. Here is the `vfsops` data structure:
{{{
/*!	@struct vfsops
	The vfs operations
*/
struct vfsops {
	/*! This mounts the file system. If it succeeds then the file system is linked into the list of mounted file systems, and the vfs_vnodecovered filed is set to point to the vnode for the mount point. */
	int	(*vfs_mount)();
	/*! This unmounts the file system. It takes the mounted file system out of the linked list of mounted file systems. */
	int	(*vfs_unmount)();
	/*! This gets the inode number for the root vnode. */
	int	(*vfs_root)();
	int	(*vfs_statfs)();
	int	(*vfs_sync)();
	int	(*vfs_fid)();
	int	(*vfs_vget)();
};
}}}
Just some historical perspective I guess ;) (pqnelson)

- eg.,
{{{
# echo "/mnt/sdc1" | /dev/sdc1/mount
}}}
As far as VFS calls go, I see an open(),write(), and close(). No need for a mount(). In this case the SCSI disk process would register itself at '/dev/sd', and on the open it would parse "c1/mount" and associate it with the appropriate routines for mounting disk 'c' and partition '1'. (jdt)

= Conclusion =

I think Brainix needs to set itself apart from other UNIX-clones.  You have already started from the ground up with a micro-kernel, which tells me that Brainix is meant to be "correct" and "elegant", rather than having a "just get it done" attitude.  With respect to this, I think a unique and elegant high-level VFS would complement this existing motive, and set itself apart from other clones.

Also, I think that this respects the spirit of UNIX better by sticking to the "everything is a file" religion.  This VFS also cures many of the issues Alex pointed us to in [http://www.faqs.org/docs/artu/ch20s03.html Problems in the Design of Unix].

= An Idea =

Just a thought, the Solaris/BSD virtual file system implementation has a `vfs` data structure representing mounted file systems. Why not have the process pseudo-file system be represented by a `struct vfs proc` data structure with process specific operations...that way the following command line works:
{{{
$ sudo rm -rf /proc/4 # kills the process with the process id of (pid==4)
}}}
The various pseudo-file systems would be implemented as `vfs struct`s. The operations wouldn't change as far as the shell is concerned, but "under the hood" the operations would be different. Just a thought that might drastically simplify the implementation of the desired design. (pqnelson)

I like that Alex.
I noticed some comments [http://code.google.com/p/brainix/wiki/FileSystemAndProcessManager here] about how the HURD has a server/process dedicated to process execution.  I like this idea because the process server could register itself as capable of exporting a namespace/objectmodel and mount itself at /proc.  The wiki previously mentioned issues about where to place fork() execve() and exit().  Why not make these objects of the process server?  eg.,
{{{
#!/bin/sh
# fork the current process (a pid could be used instead of 'current')
/proc/current/fork
if [ $? -eq "0" ]; then
    do_child
elif [ $? -gt 0 ]; then
    do_parent
else
    echo "failed to fork current process"
fi
}}}
another example:
{{{
# rm /proc/4
# /proc/4/exit # does the same thing
# /proc/4/kill -9 # same result
}}}
I don't immediately see a way of avoiding execve() because it is the method for instantiating the objects.
crazy?  I'm not sure, but it would eliminate tons of system calls. (jdt)

= RPC vs. REST/CRUD =

I just noticed that the changes I'm proposing are the same as those when converting from an [http://en.wikipedia.org/wiki/Representational_State_Transfer#Example RPC representation to a RESTful representation] of the files and functionality abstracted by the kernel.  Notice how instead of defining many different syscalls as in RPC, the REST/CRUD model follows a simple set of 4 I/O operations and access to different files/functionality is moved to a hierarchy of names.  In other words, this high-level VFS proposal is more "web-like". (jdt)

- I'm preparing to leave town for the D Programming Conference in Seattle, Washington, but here are a few preliminary thoughts: it seems that this is a simple map where a "location" is a synonym (an alias if you will) for a file. This, RPC paradigm translated into file crap, becomes a simple dictionary then. But I see we are focusing on the REST approach, so 86 that dictionary then. Perhaps instead of using "http://" we could use "file://", but this approach would change the file hierarchy no? So instead of having "/dev/null" we would have "file://root/dev/null" (or more appropriately "file:///dev/null")? I think the resource approach is more object oriented, more unix-like iff we make a resource an alias for a file. Or we represent it as-a file, vnode, what have you. This idea I will think about for a bit. I'll be back Saturday the 25th, but I'll try: thinking about this some more, revising my research to be more comprehensive, and having fun at the conference :) (pqnelson)