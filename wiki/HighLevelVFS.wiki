#summary Some Clarification on Virtual File Systems

= Introduction =

I'm putting this here because I don't want to taint [http://code.google.com/p/brainix/wiki/virtualFileSystem Alex's fine research] on different VFS implentations with my naive opinions.

It appears to me that there should be two levels of VFS.  A high-level VFS which abstracts a virtual namespace which is presented to the user, and a low-level VFS which abstracts the physical file-systems that the OS supports.

= Details =

Since Alex has already touched on several different low-level implementations of virtual file systems, I'd like to propose a higher-level implementation which would co-exist with a lower-level implementation.

Brainix processes would register themselves as being capable of exporting a namespace to the VFS along with a preferred mount point in the global namespace.  The VFS would then store in memory every registered mountpoint/process pair in some efficient hash of the mountpoint name.  When an open() is handled, it would search this hash for the longest matching mountpoint and forward the request to the matching process.  Most normal requests for actual file access would end up mapping to whichever process is mounted to root '/' and, in this case, passed on to the ext2 process (which would have registered itself with the higher-level VFS as '/' during the bootstrap process).
If implemented, any Brainix process/module/driver could then mount its capabilities/settings somewhere on the global namespace.  Namely, the network subsystem could register itself during its initialization to eg. '/sys/net'.  Device drivers could also do the same thing for the '/dev/' namespace.

The VFS would also have to forward any opened file requests via their integer file descriptor to the process determined during the call to open().  This mapping would also have to be stored in memory.

Obviously this is not new.  Linux has gone through /proc, devfs, udev, sysfs, and FUSE which accomplish the same goals.

= VFS Ops =

It is my opinion that only a small subset of traditional syscall/vfs routines are necessary for such a system:
{{{
typedef struct
{
    long (*open)(const char* filename, int flags, int mode);
    long (*close)(unsigned int fd, int flags);
    size_t (*read)(unsigned int fd, char *buf, size_t count);
    size_t (*write)(unsigned int fd, const char *buf, size_t count);
} vfs_ops_t;
}}}

Regarding the many missing routines, see my [http://code.google.com/p/brainix/wiki/RejuvenateUNIX writing] on using the namespace to replace syscall/VFS functionality.  Essentially, we can use standard and unique filenames as replacements for the missing routines.  We could either use the "^." hidden file nomenclature, or I would prefer a prefix that wouldn't collide with existing tradition eg., a comma instead of a dot.

= Conclusion =

I think Brainix needs to set itself apart from other UNIX-clones.  You have already started from the ground up with a micro-kernel, which tells me that Brainix is meant to be "correct" and "elegant", rather than having a "just get it done" attitude.  With respect to this, I think a unique and elegant high-level VFS would complement this existing motive, and set itself apart from other clones.

Also, I think that this respects the spirit of UNIX better by sticking to the "everything is a file" religion.  This VFS also cures many of the issues Alex pointed us to in [http://www.faqs.org/docs/artu/ch20s03.html Problems in the Design of Unix].



